# $Id$
# $MirOS: src/bin/mksh/dot.mkshrc,v 1.89 2014/07/28 21:45:44 tg Exp $
#-
# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010,
#		2011, 2012, 2013, 2014
#	Thorsten Glaser <tg@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# ${ENV:-~/.mkshrc}: mksh initialisation file for interactive shells

# catch non-mksh (including lksh) trying to shell this file
case $KSH_VERSION in
*MIRBSD\ KSH*) ;;
*) return 0 ;;
esac

# base64 encoder and decoder, RFC compliant, NUL safe
function Lb64decode {
	[[ -o utf8-mode ]]; local u=$?
	set +U
	local c s="$*" t=
	[[ -n $s ]] || { s=$(cat; print x); s=${s%x}; }
	local -i i=0 j=0 n=${#s} p=0 v x
	local -i16 o

	while (( i < n )); do
		c=${s:(i++):1}
		case $c {
		(=)	break ;;
		([A-Z])	(( v = 1#$c - 65 )) ;;
		([a-z])	(( v = 1#$c - 71 )) ;;
		([0-9])	(( v = 1#$c + 4 )) ;;
		(+)	v=62 ;;
		(/)	v=63 ;;
		(*)	continue ;;
		}
		(( x = (x << 6) | v ))
		case $((p++)) {
		(0)	continue ;;
		(1)	(( o = (x >> 4) & 255 )) ;;
		(2)	(( o = (x >> 2) & 255 )) ;;
		(3)	(( o = x & 255 ))
			p=0
			;;
		}
		t+=\\x${o#16#}
		(( ++j & 4095 )) && continue
		print -n $t
		t=
	done
	print -n $t
	(( u )) || set -U
}

set -A Lb64encode_code -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
    a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /
function Lb64encode {
	[[ -o utf8-mode ]]; local u=$?
	set +U
	local c s t
	if (( $# )); then
		read -raN-1 s <<<"$*"
		unset s[${#s[*]}-1]
	else
		read -raN-1 s
	fi
	local -i i=0 n=${#s[*]} j v

	while (( i < n )); do
		(( v = s[i++] << 16 ))
		(( j = i < n ? s[i++] : 0 ))
		(( v |= j << 8 ))
		(( j = i < n ? s[i++] : 0 ))
		(( v |= j ))
		t+=${Lb64encode_code[v >> 18]}${Lb64encode_code[v >> 12 & 63]}
		c=${Lb64encode_code[v >> 6 & 63]}
		if (( i <= n )); then
			t+=$c${Lb64encode_code[v & 63]}
		elif (( i == n + 1 )); then
			t+=$c=
		else
			t+===
		fi
		if (( ${#t} == 76 || i >= n )); then
			print $t
			t=
		fi
	done
	(( u )) || set -U
}

# Better Avalanche for the Jenkins Hash
typeset -Z11 -Uui16 Lbafh_v
function Lbafh_init {
	Lbafh_v=0
}
function Lbafh_add {
	[[ -o utf8-mode ]]; local u=$?
	set +U
	local s
	if (( $# )); then
		read -raN-1 s <<<"$*"
		unset s[${#s[*]}-1]
	else
		read -raN-1 s
	fi
	local -i i=0 n=${#s[*]}

	while (( i < n )); do
		((# Lbafh_v = (Lbafh_v + s[i++] + 1) * 1025 ))
		((# Lbafh_v ^= Lbafh_v >> 6 ))
	done

	(( u )) || set -U
}
function Lbafh_finish {
	local -Ui t

	((# t = (((Lbafh_v >> 7) & 0x01010101) * 0x1B) ^ \
	    ((Lbafh_v << 1) & 0xFEFEFEFE) ))
	((# Lbafh_v = t ^ (t >>> 8) ^ (Lbafh_v >>> 8) ^ \
	    (Lbafh_v >>> 16) ^ (Lbafh_v >>> 24) ))
	:
}
if \command -v hd >/dev/null; then \:; elif \command -v hexdump >/dev/null; then
	function hd {
		hexdump -e '"%08.8_ax  " 8/1 "%02X " " - " 8/1 "%02X "' \
			-e '"  |" "%_p"' -e '"|\n"' "$@"
	}
fi

# mksh-specific from here
\: "${MKSH:=$(\builtin whence -p mksh)}"; \: "${MKSH:=/bin/mksh}"; \export MKSH
HISTFILE=$HOME/.mksh_history
HISTSIZE=1000
SHELL=$MKSH
export HISTFILE HISTSIZE SHELL

[ -z "$SSH_AUTH_SOCK" ] && [ -r ~/.cache/ssh-agent-info ] && \
	. ~/.cache/ssh-agent-info

[ -r ~/.aliases ] && . ~/.aliases

case "$TERM" in
xterm|screen|*-256color)
	alias weechat='print "\033]0;weechat\a$d$s$e$i " && weechat'
	PS1=$'\001\r''$(\
((e=$?)) && e="?\e[0;31;40m$e\e[0m" || e=
d=${PWD/$HOME/\~}; d=${d##*/};\
[ "$SSH_CONNECTION" ] && s="@${HOSTNAME:=$(hostname)}" || s=;\
i=\#; ((USER_ID)) && i=\$;\
\print "\033]0;$d$s$i\a$d$s$e$i") '
;;
network|dump|*)
	PS1=$'\001\r''$(\
((r=$?)) && e="?$r" || e=;\
d=${PWD/$HOME/\~}; d=${d##*/};\
[ "$SSH_CONNECTION" ] && s="@${HOSTNAME:=$(hostname)}" || s=;\
((USER_ID)) && i=\$ || i=\#;\
print "$d$s$e$i ")'
;;
esac
